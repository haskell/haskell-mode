\input texinfo          @c -*-texinfo-*-
@c %**start of header
@setfilename haskell-mode.info
@documentencoding UTF-8
@settitle Haskell Mode 16.1-git
@c %**end of header

@c Macro used to mark references of defcustom variables
@macro defcustom{var}
@vrindex \var\
@code{\var\}
@end macro

@dircategory Emacs
@direntry
* Haskell Mode: (haskell-mode).             Haskell Development Environment for Emacs(en)
@end direntry

@copying
This manual is for Haskell mode, version 16.1-git

Copyright @copyright{} 2013-2017 Haskell Mode contributors.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @uref{http://www.gnu.org/licenses/fdl.html,GNU
Free Documentation License}, Version 1.3 or any later version published
by the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts and no Back-Cover Texts.
@end quotation
@end copying

@iftex
@titlepage
@title Haskell Mode
@subtitle Haskell Development Environment for Emacs

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents
@end iftex

@ifnottex
@node Top
@top Haskell Mode

Haskell Mode is an Haskell development Environment for GNU Emacs version
24.3 or later.  It provides syntax-based indentation, font locking,
editing cabal files, and supports running an inferior Haskell
interpreter (e.g. GHCi).

@end ifnottex

@menu
* Introduction::                         An introduction to Haskell Mode
* Installation::                         How to get started
* Editing Haskell Code::                 How to edit code
* Syntax highlighting::                  Haskell Mode has colors
* Completion support::                   Autocomplete
* Unicode support::                      How to use Unicode
* Indentation::                          Notes about indentation
* External indentation::                 Other ways to indent code
* Autoformating::                        Using external formatters
* Module templates::                     Module templates
* Declaration scanning::                 How to navigate in a source file
* Compilation::                          How to compile
* Interactive Haskell::                  How to interact with GHCi
* Editing Cabal files::                  Cabal support
* Browsing Haddocks::                    Using @code{w3m} to browse documentation
* Spell checking strings and comments::  Using @code{flyspell-prog-mode}
* Aligning code::                        Aligning code using @code{align-regexp}
* Rectangular commands::                 Manage indentation manually
* REPL::                                 GHCi REPL
* Global-Eldoc::                         Shows documentation at point
* Collapsing Haskell code::              View more code on screen
* Getting Help and Reporting Bugs::      How to improve Haskell Mode
* Concept index::                        Index of Haskell Mode concepts
* Function index::                       Index of commands
* Variable index::                       Index of options and types
@end menu

@ifhtml
@insertcopying
@end ifhtml


@node Introduction
@chapter Introduction

@dfn{Haskell Mode} is a major mode providing a convenient environment
for editing @uref{http://www.haskell.org,Haskell} programs.

Some of its major features are:

@itemize
@item
Syntax highlighting (font lock),
@item
automatic semi-intelligent indentation,
@item
on-the-fly documentation,
@item
interaction with inferior GHCi/Hugs instance,
@item
project building with cabal and stack
@item
scanning declarations and placing them in a menu.
@end itemize

The name Haskell Mode refers to the whole collection of modules in this
package. There is specifically a file @file{haskell-mode.el} which
defines a major mode called @code{haskell-mode}. Generally, in this
documentation they will be distinguished by normal font and title case
(Haskell Mode) and code font (@code{haskell-mode}).

@section History

@code{haskell-mode} has a long history. It goes all the way back
to 1992. Since then, it has received many contributions in many
forms. Some design choices that remain in haskell-mode today are
historical. Some modules are outdated or no longer used, or are used
by a few people.

Historically there hasn't been a single individual or set of
individuals directing the package's architecture for a long period of
time, rather, patches and new modules were accepted in liberally and
we are left with a box full of interesting toys that may or may not
work.

As of 2016 Haskell Mode is coordinated using Github at
@uref{https://github.com/haskell/haskell-mode}.

@node Installation
@chapter Installation

Haskell Mode is distributed as a package in
@uref{https://melpa.org,MELPA repository}. To use MELPA as Emacs package
archive do the following:

@enumerate
@item
Customize @code{package-archives} using
@example
M-x customize-option RET package-archives
@end example
@item
Use @kbd{INS} to add new archive, use:
@example
Archive name:          melpa-stable
URL or directory name: http://stable.melpa.org/packages/
@end example
@item
Fetch new packages using:
@example
M-x package-refresh-contents
@end example
@item
Install Haskell Mode using:
@example
M-x package-install RET haskell-mode RET
@end example
@end enumerate

Voila! @code{haskell-mode} is installed! You should be able to edit Haskell
source code in color now.

The above steps should result in the following snippet in your @file{.emacs}:

@lisp
(require 'package)
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(package-archives
   (quote
    (("gnu" . "http://elpa.gnu.org/packages/")
     ("melpa-stable" . "http://stable.melpa.org/packages/")))))
@end lisp


Haskell Mode supports GNU Emacs versions 24.3+, including 25
(snapshot).

Haskell Mode is available from
@uref{http://stable.melpa.org,melpa-stable (releases)} and
@uref{http://melpa.org, melpa (git snapshots)}.

Other means of obtaining @code{haskell-mode} include
@uref{https://github.com/dimitri/el-get, el-get},
@uref{https://github.com/bbatsov/prelude, Emacs Prelude} and
@uref{https://packages.debian.org/search?keywords=haskell-mode, Debian package}.

Last version of @code{haskell-mode} that supported Emacs 23, 24.1, and 24.2 is
@code{haskell-mode} 13.16 available at
@uref{https://github.com/haskell/haskell-mode/releases/tag/v13.16}.

@section Customizing

@cindex customizing
Most of Haskell Mode's settings are configurable via customizable
variables (@pxref{Easy Customization,,,emacs}, for details). You can use
@kbd{M-x customize-group @key{RET} haskell} to browse the @code{haskell}
customization sub-tree.

@vindex haskell-mode-hook
One of the important setting you should customize is the
@code{haskell-mode-hook} variable (@pxref{Hooks,,,emacs}) which gets run
right after the @code{haskell-mode} major mode is initialized for a
buffer. You can customize @code{haskell-mode-hook} by

@example
M-x customize-variable RET haskell-mode-hook
@end example

There you can enable or disable a couple of predefined options or add
any function to the list.

@node Editing Haskell Code
@chapter Editing Haskell Code

@findex haskell-mode
@cindex @code{haskell-mode}

Haskell Mode as one of its components provides a major mode for editing
Haskell source code called @code{haskell-mode}, which gave the name to
the whole project. There is a derived mode provided called
@code{literate-haskell-mode} that support Literate Haskell source code
both in Bird and in Latex forms.

Haskell Mode supports files with the following extensions:

@table @file
@item .hs
official file extension for Haskell files. Haskell Mode out of the box
supports most of GHC extensions.
@item .lhs
official file extension for Literate Haskell files. Both Bird and Latex
styles are supported.
@item .hsc
Haskell interfaces to C code used by @uref{http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html,hsc2hs}
pre-processor.
@item .cpphs
Haskell source with CPP pragmas used with @uref{http://projects.haskell.org/cpphs,cpphs}
pre-processor.
@item .c2hs
Haskell FFI bindings to C libraries used with @uref{https://github.com/haskell/c2hs,c2hs}
pre-processor.
@end table

Haskell Mode offers many productivity tools described in following
chapters in this manual.

@section Managing imports

There are a few functions for managing imports.

@subsection Jump to imports

To jump to your import list, run

    @kbd{M-x} @code{haskell-navigate-imports}

It's nicer to have a keybinding to do this, for example:

@lisp
(define-key haskell-mode-map (kbd "<f8>") 'haskell-navigate-imports)
@end lisp

You can hit it repeatedly to jump between groups of imports. It will
cycle.

@subsection Format imports

To generally format (sort, align) your imports, you can run

    @kbd{M-x} @code{haskell-mode-format-imports}

Or @kbd{C-c C-,}.

@subsection Sort imports

To just sort imports, jump to an import section and run

    @kbd{M-x} @code{haskell-sort-imports}

@subsection Align imports

To just align imports, jump to an import section and run

    @kbd{M-x} @code{haskell-align-imports}

@subsection stylish-haskell

As an alternative to the elisp functions described above, haskell-mode
can use the program
@url{http://hackage.haskell.org/package/stylish-haskell,
stylish-haskell} to format imports.  You can set this behavior by
typing: @kbd{M-x} @code{customize-variable} @kbd{RET}
@code{haskell-stylish-on-save}.  You can install
@code{stylish-haskell} by running @code{stack install
stylish-haskell}, or if you have not installed @code{stack},
@code{cabal install stylish-haskell}.

@section Haskell Tags

@code{haskell-mode} can generate tags when saving source files.  To
generate tags @code{haskell-mode} uses external program ‚Äî
@url{https://github.com/MarcWeber/hasktags, Hasktags}
(@url{https://wiki.haskell.org/Tags, wiki-article}).  To turn on tags
generatation customize or set to @code{t} @code{haskell-tags-on-save}
variable.  Also, you may find useful to revert tags tables
automatically, this can be done by customizing
@code{tags-revert-without-query} variable (either globally or for
Haskell buffers only).

@section Profiling and Debugging support

When profiling code with GHC, it is often useful to add
@uref{https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#cost-centres,
cost centres} by hand.  These allow finer-grained information about
program behavior.  @code{haskell-mode} provides the function
@code{haskell-mode-toggle-scc-at-point} to make this more convenient.
It will remove an SCC annotation at point if one is present, or add
one if point is over whitespace.  By default it is bound to @kbd{C-c C-s}.

@node Syntax highlighting
@chapter Syntax highlighting

@code{haskell-mode} supports @dfn{syntax highlighting} via Emacs' Font
Lock minor mode which should be enabled by default in current
Emacsen. @xref{Font Lock,,,emacs}, for more information on how to
control @code{font-lock-mode}.

@ifhtml
@image{anim/font-lock}
@end ifhtml

Syntax highlighting facilities parse strings and string escape sequences
and are able to highlight unrecognized constructs.

@ifhtml
@image{anim/string-escape-highlight}
@end ifhtml

Haskell Mode shows keywords, identifiers, operators, constructors and
types in different colors.

@ifhtml
@image{anim/font-lock-types}
@end ifhtml

There is also support to use mode-specific syntax highlighing for
quasiquotes.

@ifhtml
@image{anim/font-lock-quasi-quotes}
@end ifhtml

At this point quasi quotes for HTML, XML, shell scripts, Hamlet
templates and SQL are supported out of the box. Customize
@code{haskell-font-lock-quasi-quote-modes} to make sure your quoters are
supported.

The following customization variables are responsible for faces applied:

@itemize @code
@item @defcustom{haskell-keyword-face}: for keywords
@item @defcustom{haskell-type-face}: for type names and type class names
@item @defcustom{haskell-constructor-face}: for constructors
@item @defcustom{haskell-definition-face}: function and operator name at the definition place
@item @defcustom{haskell-operator-face}: operators
@item @defcustom{haskell-pragma-face}: GHC pragmas
@item @defcustom{haskell-literate-comment-face}: literate comments
@item @defcustom{haskell-quasi-quote-face}: quasi quotes unless using mode specific highlighting
@item @defcustom{haskell-c2hs-hook-pair-face}: c2hs hooks
@item @defcustom{haskell-c2hs-hook-name-face}: c2hs hook names
@end itemize

All the above are available for customization.

GHC quasi quote syntax is ambiguous with list comprehension therefore
syntax highlighting might get confused with situations like these:

@example
result = [html| html <- htmlList]
result = [html| <html><body>...</body></html> |]
@end example

Please use spaces around a list comprehension variable to make this
unambiguous. Any of the following will work:

@example
result = [ html| html <- htmlList]
result = [html | html <- htmlList]
@end example

GHC's ambiguity is an accident of the past but it is unlikely to be
fixed due to backward compatibility baggage.

@node Completion support
@chapter Completion support

@code{haskell-mode} can complete symbols, pragma directives, language
extensions, and language keywords out-of-box.  @code{haskell-mode}
completes identifiers (symbols) using tags (see ``Tags''), however you
can get more precise completions with @code{haskell-interactive-mode}.
In interactive mode completion candidates are produced by querying
GHCi REPL.

@ifhtml
@image{anim/company-mode-language-pragma}
@end ifhtml

If @code{haskell-interactive-mode} is enabled and working Haskell mode
provides completions for import statements taking into account
currently loaded and available packages.  Also it completes symbols
querying REPL with @code{:complete} command, hence completion
candidate list also includes symbols from imported modules.

@ifhtml
@image{anim/company-mode-import-statement}
@end ifhtml

Unfortunatelly, it is not possible to provide candidates for
identifiers defined locally in @code{let} and @code{where} blocks even
in interactive mode.  But if you're using
@url{http://company-mode.github.io/, company-mode} you can override
@code{company-backends} variable for Haskell buffers to combine
completion candidates from completion-at-point function
(@code{company-capf} backend) and dynamic abbrevs.
@code{company-mode} provides special backend for dabbrev code
completions, namely @code{company-dabbrev-code}.  To combine
completions from diffrent backends you can create grouped backends, it
is very easy ‚Äî a grouped backend is just a list of backends, for
example:

@lisp
(add-hook 'haskell-mode-hook
          (lambda ()
            (set (make-local-variable 'company-backends)
                 (append '((company-capf company-dabbrev-code))
                         company-backends))))
@end lisp

If you use a GHCi version prior to 8.0.1 you might want to set
@code{haskell-completions-complete-operators} to @code{nil}, if you
experience major slowdown while trying to complete after an Haskell
operator (See @url{https://ghc.haskell.org/trac/ghc/ticket/10576, GHC-Bug 10576}).

@node Unicode support
@chapter Unicode support

@cindex Unicode

See the Haskell Wiki's entry on
@uref{http://www.haskell.org/haskellwiki/Unicode-symbols, Unicode
Symbols} for general information about Unicode support in Haskell.

As Emacs supports editing files containing Unicode out of the box, so
does Haskell Mode. As an add-on, Haskell Mode includes the
@code{haskell-unicode} input method which allows you to easily type a
number of Unicode symbols that are useful when writing Haskell code;
@xref{Input Methods,,,emacs}, for more details.

To automatically enable the @code{haskell-unicode} input method in
haskell-mode buffers use @kbd{M-x customize-variable @key{RET}
haskell-mode-hook} or put the following code in your @file{.emacs} file:

@lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-unicode-input-method)
@end lisp

@noindent
To temporarily enable this input method for a single buffer you can use
@kbd{M-x turn-on-haskell-unicode-input-method}.

When the @code{haskell-unicode} input method is active, you can simply
type @samp{->} and it is immediately replaced with @samp{‚Üí}. Use
@kbd{C-\} to toggle the input method. To see a table of all key
sequences use @kbd{M-x describe-input-method @key{RET}
haskell-unicode}. A sequence like @samp{<=} is ambiguous and can mean
either @samp{‚áê} or @samp{‚â§}. Typing it presents you with a choice. Type
@kbd{1} or @kbd{2} to select an option or keep typing to use the default
option.

Currently defined sequences are listed in the following table:

@multitable @columnfractions .08 .15 .08 .15 .08 .15 .08 .15
@headitem Sequence @tab Unicode @tab Sequence @tab Unicode @tab Sequence @tab Unicode @tab Sequence @tab Unicode
@item alpha
@tab Œ±
@tab Alpha
@tab Œë
@tab beta
@tab Œ≤
@tab Beta
@tab Œí
@item gamma
@tab Œ≥
@tab Gamma
@tab Œì
@tab delta
@tab Œ¥
@tab Delta
@tab Œî
@item epsilon
@tab Œµ
@tab Epsilon
@tab Œï
@tab zeta
@tab Œ∂
@tab Zeta
@tab Œñ
@item eta
@tab Œ∑
@tab Eta
@tab Œó
@tab theta
@tab Œ∏
@tab Theta
@tab Œò
@item iota
@tab Œπ
@tab Iota
@tab Œô
@tab kappa
@tab Œ∫
@tab Kappa
@tab Œö
@item lambda
@tab Œª
@tab Lambda
@tab Œõ
@tab lamda
@tab Œª
@tab Lamda
@tab Œõ
@item mu
@tab Œº
@tab Mu
@tab Œú
@tab nu
@tab ŒΩ
@tab Nu
@tab Œù
@item xi
@tab Œæ
@tab Xi
@tab Œû
@tab omicron
@tab Œø
@tab Omicron
@tab Œü
@item pi
@tab œÄ
@tab Pi
@tab Œ†
@tab rho
@tab œÅ
@tab Rho
@tab Œ°
@item sigma
@tab œÉ
@tab Sigma
@tab Œ£
@tab tau
@tab œÑ
@tab Tau
@tab Œ§
@item upsilon
@tab œÖ
@tab Upsilon
@tab Œ•
@tab phi
@tab œÜ
@tab Phi
@tab Œ¶
@item chi
@tab œá
@tab Chi
@tab Œß
@tab psi
@tab œà
@tab Psi
@tab Œ®
@item omega
@tab œâ
@tab Omega
@tab Œ©
@tab digamma
@tab œù
@tab Digamma
@tab œú
@item san
@tab œª
@tab San
@tab œ∫
@tab qoppa
@tab œô
@tab Qoppa
@tab œò
@item sampi
@tab œ°
@tab Sampi
@tab œ†
@tab stigma
@tab œõ
@tab Stigma
@tab œö
@item heta
@tab Õ±
@tab Heta
@tab Õ∞
@tab sho
@tab œ∏
@tab Sho
@tab œ∑
@item |A|
@tab ùî∏
@tab |B|
@tab ùîπ
@tab |C|
@tab ‚ÑÇ
@tab |D|
@tab ùîª
@item |E|
@tab ùîº
@tab |F|
@tab ùîΩ
@tab |G|
@tab ùîæ
@tab |H|
@tab ‚Ñç
@item |I|
@tab ùïÄ
@tab |J|
@tab ùïÅ
@tab |K|
@tab ùïÇ
@tab |L|
@tab ùïÉ
@item |M|
@tab ùïÑ
@tab |N|
@tab ‚Ñï
@tab |O|
@tab ùïÜ
@tab |P|
@tab ‚Ñô
@item |Q|
@tab ‚Ñö
@tab |R|
@tab ‚Ñù
@tab |S|
@tab ùïä
@tab |T|
@tab ùïã
@item |U|
@tab ùïå
@tab |V|
@tab ùïç
@tab |W|
@tab ùïé
@tab |X|
@tab ùïè
@item |Y|
@tab ùïê
@tab |Z|
@tab ‚Ñ§
@tab |gamma|
@tab ‚ÑΩ
@tab |Gamma|
@tab ‚Ñæ
@item |pi|
@tab ‚Ñº
@tab |Pi|
@tab ‚Ñø
@tab ::
@tab ‚à∑
@tab forall
@tab ‚àÄ
@item exists
@tab ‚àÉ
@tab ->
@tab ‚Üí
@tab <-
@tab ‚Üê
@tab =>
@tab ‚áí
@item ~>
@tab ‚áù
@tab <~
@tab ‚áú
@tab &&
@tab ‚àß
@tab ||
@tab ‚à®
@item ==
@tab ‚â°
@tab /=
@tab ‚â¢, ‚â†
@tab <=
@tab ‚â§
@tab >=
@tab ‚â•
@item /<
@tab ‚âÆ
@tab />
@tab ‚âØ
@tab  *
@tab  ‚ãÖ
@tab elem
@tab ‚àà
@item notElem
@tab ‚àâ
@tab member
@tab ‚àà
@tab notMember
@tab ‚àâ
@tab union
@tab ‚à™
@item intersection
@tab ‚à©
@tab isSubsetOf
@tab ‚äÜ
@tab isProperSubsetOf
@tab ‚äÇ
@tab <<<
@tab ‚ãò
@item >>>
@tab ‚ãô
@tab <|
@tab ‚ä≤
@tab |>
@tab ‚ä≥
@tab ><
@tab ‚ãà
@item mappend
@tab ‚äï
@tab  .
@tab  ‚àò
@tab undefined
@tab ‚ä•
@tab :=
@tab ‚âî
@item =:
@tab ‚âï
@tab =def
@tab ‚âù
@tab =?
@tab ‚âü
@tab ...
@tab ‚Ä¶
@item _0
@tab ‚ÇÄ
@tab _1
@tab ‚ÇÅ
@tab _2
@tab ‚ÇÇ
@tab _3
@tab ‚ÇÉ
@item _4
@tab ‚ÇÑ
@tab _5
@tab ‚ÇÖ
@tab _6
@tab ‚ÇÜ
@tab _7
@tab ‚Çá
@item _8
@tab ‚Çà
@tab _9
@tab ‚Çâ
@tab ^0
@tab ‚Å∞
@tab ^1
@tab ¬π
@item ^2
@tab ¬≤
@tab ^3
@tab ¬≥
@tab ^4
@tab ‚Å¥
@tab ^5
@tab ‚Åµ
@item ^6
@tab ‚Å∂
@tab ^7
@tab ‚Å∑
@tab ^8
@tab ‚Å∏
@tab ^9
@tab ‚Åπ
@end multitable

If you don't like the highlighting of partially matching tokens you can
turn it off by setting @code{input-method-highlight-flag} to @code{nil}
via @kbd{M-x customize-variable}.

@node Indentation
@chapter Indentation

@cindex indentation
@cindex layout rule
@cindex off-side rule

In Haskell, code indentation has semantic meaning as it defines the
block structure. Haskell also supports braces and semicolons
notation for conveying the block structure. However, most Haskell
programs written by humans use indentation for block structuring.

Haskell Mode ships with two indentation modes:

@itemize
@item @code{haskell-indentation-mode} (default).

This is a semi-intelligent indentation mode doing a decent job at
recognizing Haskell syntactical constructs.  It is based on a recursive
descent Haskell parser. @kbd{TAB} selects the next potential indentation
position, @kbd{S-TAB} selects the previous one. If a block is selected
you can use @kbd{TAB} to indent the block more and @kbd{S-TAB} to indent
the block less.

When @code{electric-indent-mode} is enabled or the variable
@code{haskell-indentation-electric-flag} is non-nil, the insertion of
some characters (by default @kbd{,} @kbd{;} @kbd{)} @kbd{@}} @kbd{]})
may trigger auto reindentation under appropriate conditions. See the
documentation of @code{haskell-indentation-common-electric-command} for
more details.

@item @code{haskell-indent-mode} (optional).

This is a semi-intelligent indentation mode doing a decent job at
recognizing Haskell syntactical constructs.  It is based on a decision
table. Sadly it is no longer developed and does not recognize newer
Haskell syntax. @kbd{TAB} cycles through all available indentation
positions.

To use @code{haskell-indent-mode}, add this to your @file{~/.emacs}
file:

@lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
@end lisp

Note that @code{turn-on-haskell-indent} will disable
@code{haskell-indentation-mode}.

@end itemize

For general information about indentation support in GNU Emacs,
@pxref{Indentation,,,emacs}.

@section Rectangle Commands

@cindex rectangle
@cindex CUA mode

GNU Emacs provides so-called @dfn{rectangle commands} which operate on
rectangular areas of text, which are particularly useful for languages
with a layout rule such as Haskell. @xref{Rectangles,,,emacs}, to learn
more about rectangle commands.

Moreover, CUA mode (@pxref{CUA Bindings,,,emacs}) provides enhanced
rectangle support with visible rectangle highlighting. When CUA mode is
active, you can initiate a rectangle selection by @kbd{C-RET} and extend
it simply by movement commands. You don't have to enable full CUA mode
to benefit from these enhanced rectangle commands; you can activate CUA
selection mode (without redefining @kbd{C-x},@kbd{C-c},@kbd{C-v}, and
@kbd{C-z}) by calling @kbd{M-x cua-selection-mode} (or adding
@code{(cua-selection-mode nil)} to your @code{haskell-mode-hook}).

@section Region indent is a no-op

There is a @code{indent-region} function that supposedly could be used
to indent code region without changing its semantics. Sadly it does not
work that way because usual use case for @code{indent-region} is:

@enumerate
@item
Alter first line of code in region.
@item
Call @code{indent-region} to fix indentation for remaining lines.
@end enumerate

Note that between 1 and 2 program is already semantically broken and
knowing how to indent it preserving semantic from before step 1 would
require time travel.

To stay on the safe side @code{indent-region-function} is bound to a
no-op in @code{haskell-mode}.

@node External indentation
@chapter Other ways to indent code

@section Indentation with tabs, not spaces

Some projects require indenting code with tabs and forbid indenting it
with spaces.  For hacking on such projects, check out
@uref{https://spwhitton.name/tech/code/haskell-tab-indent,haskell-tab-indent-mode}.

@section Structured indentation

Another alternative is to install
@uref{https://github.com/chrisdone/structured-haskell-mode,structured-haskell-mode}.
which indents code by parsing the code with a full Haskell parser and
deciding where to indent based on that.

@node Autoformating
@chapter Using external formatters

You can enable @uref{https://github.com/jaspervdj/stylish-haskell,stylish-haskell} by
installing it:

@example
$ cabal install stylish-haskell
@end example

And by enabling it with a customization

@lisp
(custom-set-variables
 '(haskell-stylish-on-save t))
@end lisp

Now when you run @code{save-buffer} (or @kbd{C-x C-s}) the module will
be automatically formatted.

Alternatively, you can run the function directly on demand with
@kbd{M-x} @code{haskell-mode-stylish-buffer}.

@node Module templates
@chapter Module templates

To enable auto-insertion of module templates, enable:

@lisp
(add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template)
@end lisp

When you open a file called @file{Foo.hs}, it will auto-insert

@example
-- |

module Foo where
@end example

And put your cursor in the comment section.

@node Declaration scanning
@chapter Declaration scannning

@findex haskell-decl-scan-mode
@vindex haskell-decl-scan-mode-hook

@code{haskell-decl-scan-mode} is a minor mode which performs declaration
scanning and provides @kbd{M-x imenu} support (@pxref{Imenu,,,emacs} for
more information).

For non-literate and @TeX{}-style literate scripts, the common
convention that top-level declarations start at the first column is
assumed.  For Bird-style literate scripts, the common convention that
top-level declarations start at the third column, ie. after @samp{> },
is assumed.

When @code{haskell-decl-scan-mode} is active, the standard Emacs
top-level definition movement commands (@pxref{Moving by
Defuns,,,emacs}) are enabled to operate on Haskell declarations:

@table @kbd
@item C-M-a
Move to beginning of current or preceding declaration
(@code{beginning-of-defun}).

@item C-M-e
Move to end of current or following declaration (@code{end-of-defun}).

@item C-M-h
Select whole current or following declaration (@code{mark-defun}).
@end table

Moreover, if enabled via the option
@code{haskell-decl-scan-add-to-menubar}, a menu item ``Declarations'' is
added to the menu bar listing the scanned declarations and allowing to
jump to declarations in the source buffer.

It's recommended to have font lock mode enabled (@pxref{Font
Lock,,,emacs}) as @code{haskell-decl-scan-mode} ignores text highlighted
with @code{font-lock-comment-face}.

As usual, in order to activate @code{haskell-decl-scan-mode}
automatically for Haskell buffers, add @code{haskell-decl-scan-mode}
to @code{haskell-mode-hook}:

@lisp
(add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)
@end lisp

@code{haskell-decl-scan-mode} enables the use of features that build
upon @code{imenu} support such as Speedbar Frames
(@pxref{Speedbar,,,emacs}) or the global ``Which Function'' minor mode
(@pxref{Which Function,,,emacs}).

In order to enable @code{which-function-mode} for Haskell buffers you
need to add the following to your Emacs initialization:

@lisp
(eval-after-load "which-func"
  '(add-to-list 'which-func-modes 'haskell-mode))
@end lisp

@section Speedbar

Haskell-mode comes with declaration scanning support. This means that if you enable Haskell support for speedbar:

@lisp
(speedbar-add-supported-extension ".hs")
@end lisp

And open speedbar with

@code{M-x speedbar}

It gives a listing of each module and under each module:

@example
    Imports
    Instances
    Data types
    Classes
    Bindings
@end example

You will get a bar that looks like this:

@verbatim
~/Projects/ace/src/ACE/
0:<+> Types
0:[+] Combinators.hs
0:[-] Datalog.hs
1:   {-} Classes
2:      > ToTerm
1:   {-} Imports
2:      > ACE.Types.Syntax
2:      > Database.Datalog
1:   {-} Instances
2:    {+} ToTerm A
2:    {+} ToTerm Co to ToTerm Gen
2:    {+} ToTerm Intransitive to ToTerm N
2:    {+} ToTerm P
2:    {+} ToTerm Quotation to ToTerm Un
2:    {+} ToTerm V
0:[-] Html.hs
1:   {+} Imports
1:   {+} Instances
1:     > mtoMarkup
1:     > toMarkupm
1:     > wrap
0:[-] Parsers.hs
1:   {+} Imports
1:   {-} Datatypes
2:      > ACEParser
0:[+] Pretty.hs
0:[+] Tokenizer.hs
@end verbatim

The hierarchy is expandable/collapsible and each entry will jump to the
line in the right file when clicked/selected.

@node Compilation
@chapter Compilation

@findex haskell-compile

Haskell mode comes equipped with a specialized @dfn{Compilation mode}
tailored to GHC's compiler messages with optional support for Cabal
projects. @xref{Compilation Mode,,,emacs}, for more information about
the basic commands provided by the Compilation mode which are available
in the Haskell compilation sub-mode as well. The additional features
provided compared to Emacs' basic Compilation mode are:

@itemize
@item
DWIM-style auto-detection of compile command (including support for
CABAL projects)
@item
Support for GHC's compile messages and recognizing error, warning and
info source locations (including @option{-ferror-spans} syntax)
@item
Support for filtering out GHC's uninteresting @samp{Loading package...}
linker messages
@end itemize

In order to use it, invoke the @code{haskell-compile} command instead of
@code{compile} as you would for the ordinary Compilation mode. It's
recommended to bind @code{haskell-compile} to a convenient key
binding. For instance, you can add the following to your Emacs
initialization to bind @code{haskell-compile} to @kbd{C-c C-c}.

@lisp
(eval-after-load "haskell-mode"
    '(define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile))

(eval-after-load "haskell-cabal"
    '(define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile))
@end lisp

@noindent
The following description assumes that @code{haskell-compile} has been
bound to @kbd{C-c C-c}.

@vindex haskell-compile-cabal-build-command
@vindex haskell-compile-cabal-build-command-alt
@vindex haskell-compile-command

When invoked, @code{haskell-compile} tries to guess how to compile the
Haskell program your currently visited buffer belongs to, by searching
for a @file{.cabal} file in the current of enclosing parent folders. If
a @file{.cabal} file was found, the command defined in the
@code{haskell-compile-cabal-build-command} option is used. Note that to
compile a @code{stack} based project you will need to set this variable to
@code{stack build}. As usual you can do it using @code{M-x customize-variable}
or with:

@lisp
(setq haskell-compile-cabal-build-command "stack build")
@end lisp

Moreover, when requesting to compile a @file{.cabal}-file is detected and
a negative prefix argument (e.g. @kbd{C-- C-c C-c}) was given, the
alternative @code{haskell-compile-cabal-build-command-alt} is
invoked. By default, @code{haskell-compile-cabal-build-command-alt}
contains a @samp{cabal clean -s} command in order to force a full
rebuild.

Otherwise if no @file{.cabal} could be found, a single-module
compilation is assumed and @code{haskell-compile-command} is used
(@emph{if} the currently visited buffer contains Haskell source code).

You can also inspect and modify the compile command to be invoked
temporarily by invoking @code{haskell-compile} with a prefix argument
(e.g. @kbd{C-u C-c C-c}). If later-on you want to recompile using the
same customized compile command, invoke @code{recompile} (bound to
@kbd{g}) inside the @samp{*haskell-compilation*} buffer.

@node Interactive Haskell
@chapter Interactive Haskell

@code{interactive-haskell-mode} is the minor mode that provides interactive
editing features. Most of these features are provided by querying the haskell
REPL processes.

@section Enable this mode

Run the function @kbd{M-x interactive-haskell-mode}

If you want to enable this mode permanently, then hook this mode to @code{haskell-mode} by
putting this line in your @code{.emacs} file:

@example
(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
@end example

@section Related key binding

@multitable @columnfractions 0.3 0.2 0.2 0.3
@headitem Function @tab Args @tab Key bindings @tab Description

@item @code{haskell-process-load-file}
@tab nil
@tab @kbd{C-c C-l}, @kbd{C-c C-r}
@tab Load or reload the file in current buffer, errors that might arise are put in the `*haskell-compilation*' buffer.

@item @code{haskell-mode-jump-to-def-or-tag}
@tab nil
@tab @kbd{M-.}
@tab Jump to the definition.

@item @code{haskell-cabal-visit-file}
@tab nil
@tab @kbd{C-c v c}
@tab Locate and visit package description file for file visited by current buffer.

@item @code{haskell-process-cabal}
@tab nil
@tab @kbd{C-c C-x}
@tab Prompts for a Cabal command to run.

@item @code{run-haskell}, @code{switch-to-haskell}
@tab nil
@tab @kbd{C-c C-b}, @kbd{C-c C-z}
@tab Show the inf-haskell buffer. Start the process if needed.

@item @code{haskell-compile}
@tab nil
@tab @kbd{C-c C-c}
@tab Compile the Haskell program including the current buffer.

@item @code{haskell-process-cabal-build}
@tab nil
@tab nil
@tab Run the command @code{cabal build}
@end multitable

@section More on @code{M-.}

The @code{M-.} functionality works if the file in the buffer is loaded into
the REPL (@kbd{C-c C-l}). The file in the current buffer can only be loaded
if the code doesn't contain errors. When we can succesfully load the file in
the current buffer into REPL, we can get accurate go-to function definition
with @kbd{M-.}

@subsection @code{M-.} with hasktags

Sometimes we might want to use the @kbd{M-.} functionality even when the
code doesn't compile. This is when we use TAGS.

First install @code{hasktags}.

You can run either

@example
$ cabal install hasktags
@end example

or

@example
$ stack install hasktags
@end example

Then we run @kbd{M-x haskell-mode-generate-tags} to generate tags. Now
we can use @kbd{M-.} functionality even when the code doesn't compile.

But running @kbd{M-x haskell-mode-generate-tags} everytime can be a too much
typing to do just a @kbd{M-.}. We set @code{haskell-tags-on-save} to @code{t}
and the TAGS will be generated on saving the file in buffer.

@section Related defcustoms

@multitable @columnfractions
@headitem Defcustom @tab Default value @tab Possible values

@item @code{haskell-tags-on-save} @tab nil @tab @code{nil}, @code{t}
@item @code{haskell-process-type} @tab @code{'auto} @tab @code{'stack-ghci, 'cabal-repl, 'ghci, 'auto}
@item @code{haskell-process-path-ghci} @tab @code{ghci} @tab -
@item @code{haskell-process-args-ghci} @tab @code{-ferror-spans} @tab -
@item @code{haskell-process-path-cabal} @tab @code{cabal} @tab -
@item @code{haskell-process-args-cabal-repl} @tab @code{--ghc-option=-ferror-spans} @tab -
@item @code{haskell-process-path-stack} @tab @code{stack} @tab -
@item @code{haskell-process-args-stack-ghci} @tab @code{--ghci-options=-ferror-spans --no-build --no-load} @tab -

@end multitable


@section Add Hooks

None

@end multitable

@node Editing Cabal files
@chapter Editing Cabal files

@findex haskell-cabal-mode
@vindex haskell-cabal-mode-hook

@code{haskell-cabal-mode} is a major mode for editing
@uref{http://www.haskell.org/cabal/users-guide/developing-packages.html,Cabal
package description files} and is automatically associated with files
having a @file{.cabal} extension.

@findex haskell-cabal-visit-file

For quickly locating and jumping to the nearest @file{.cabal} file from
a Haskell source buffer, you can use @kbd{M-x haskell-cabal-visit-file};
with a prefix argument (i.e. @kbd{C-u}) @code{find-file-other-window} is
used to visit the @file{.cabal} file.
@code{haskell-cabal-visit-file} is bound to the key sequence @kbd{C-c v c}.

TODO/WRITEME

@node Browsing Haddocks
@chapter Browsing Haddocks using @code{w3m}

An experimental feature is use of the w3m browser to browse Haddock docs
inside Emacs.

@section Get w3m

Most Linux distributions will have a package for the binary:

@example
$ sudo apt-get install w3m
@end example

Now grab @code{w3m.el} from:

@itemize
@item @url{http://emacs-w3m.namazu.org/}
@item @kbd{M-x} @code{package-install} @kbd{RET} @code{w3m} @kbd{RET}
@end itemize

Confirm installation by trying @kbd{M-x} @code{w3m-browse-url} @kbd{RET}
@code{haskell.org} @kbd{RET}.

If this works, you're good to go.

@section Configure w3m

Now that you have w3m, you probably want to configure it to be more of a
passive viewer than a full-fledged browser. For example:

@lisp
(setq w3m-mode-map (make-sparse-keymap))

(define-key w3m-mode-map (kbd "RET") 'w3m-view-this-url)
(define-key w3m-mode-map (kbd "q") 'bury-buffer)
(define-key w3m-mode-map (kbd "<mouse-1>") 'w3m-maybe-url)
(define-key w3m-mode-map [f5] 'w3m-reload-this-page)
(define-key w3m-mode-map (kbd "C-c C-d") 'haskell-w3m-open-haddock)
(define-key w3m-mode-map (kbd "M-<left>") 'w3m-view-previous-page)
(define-key w3m-mode-map (kbd "M-<right>") 'w3m-view-next-page)
(define-key w3m-mode-map (kbd "M-.") 'w3m-haddock-find-tag)

(defun w3m-maybe-url ()
  (interactive)
  (if (or (equal '(w3m-anchor) (get-text-property (point) 'face))
          (equal '(w3m-arrived-anchor) (get-text-property (point) 'face)))
      (w3m-view-this-url)))
@end lisp

@section Import w3m-haddock

It's not enabled by default in haskell-mode at present, so you need to
import it manually:

@lisp
(require 'w3m-haddock)
@end lisp

@section Add a hook for w3m

In order to make haddock pages a little more palatable (and add syntax
highlighting to source view), you can add this hook:

@lisp
(add-hook 'w3m-display-hook 'w3m-haddock-display)
@end lisp

It's a little rough around the edges, but it's a start.

@section Configure your package locations

By default, the package locations is set to:

@lisp
(defcustom haskell-w3m-haddock-dirs
  '("~/.cabal/share/doc/"))
@end lisp

If you are using an hsenv or a custom package directory, you should
configure this variable with M-x customize-variable or by writing the
custom-set-variables code for it.

@section Finally

You did all that! Now you're ready to bind a useful key:

@lisp
(define-key haskell-mode-map (kbd "C-c C-d") 'haskell-w3m-open-haddock)
@end lisp

Now when you press @kbd{C-c} @kbd{C-d} it will prompt for a package to
browse to.

This feature will be improved gradually as time goes on.


@node Spell checking strings and comments
@chapter Using with @code{flyspell-prog-mode}

Strings and comments can be checked for spelling mistakes. There is a
standard Emacs mode for this purpose, @code{flyspell-prog-mode}, that
can be enabled in Haskell buffers. Spelling errors are underlined using
squiggly red lines.

@ifhtml
@image{anim/flyspell-prog-mode}
@end ifhtml

Documentation for @code{flyspell-prog-mode} can be found in
@xref{Spelling,,,emacs}. Here we point to a couple of useful
keybindings:

@itemize
@item
@kbd{M-$} - Check and correct spelling of the word at point (@code{ispell-word}).

@item
@kbd{digit} - Replace the word, just this time, with one of the
displayed near-misses. Each near-miss is listed with a digit; type that
digit to select it.

@item
@kbd{SPC} - Skip this word‚Äîcontinue to consider it incorrect, but don‚Äôt
change it here.
@end itemize

To enable spell checking of strings and comments add this line to your
@code{~/.emacs} file:

@code{(add-hook 'haskell-mode-hook 'flyspell-prog-mode)}

@node Aligning code
@chapter Aligning code

Select a region you want to align text within, @kbd{M-x}
@code{align-regexp}, and type a regexp representing the alignment
delimiter.

For example, I often line up my Haddock comments:

@example
f :: a -- ^ does a
  -> Foo b -- ^ and b
  -> c -- ^ to c
@end example

Select the region, and let the regexp be @samp{--}:

@example
f :: a     -- ^ does a
  -> Foo b -- ^ and b
  -> c     -- ^ to c
@end example

Of course, this works for just about anything. Personally, I've globally
bound it to @kbd{C-x a r}:

@lisp
(global-set-key (kbd "C-x a r") 'align-regexp)
@end lisp

Note that you can also just use the rules below for telling the aligner
about Haskell. Once you evaluate this, you can just use @kbd{M-x}
@code{align}, which I like to bind to @kbd{M-[}.

@lisp
(add-to-list 'align-rules-list
             '(haskell-types
               (regexp . "\\(\\s-+\\)\\(::\\|‚à∑\\)\\s-+")
               (modes quote (haskell-mode literate-haskell-mode))))
(add-to-list 'align-rules-list
             '(haskell-assignment
               (regexp . "\\(\\s-+\\)=\\s-+")
               (modes quote (haskell-mode literate-haskell-mode))))
(add-to-list 'align-rules-list
             '(haskell-arrows
               (regexp . "\\(\\s-+\\)\\(->\\|‚Üí\\)\\s-+")
               (modes quote (haskell-mode literate-haskell-mode))))
(add-to-list 'align-rules-list
             '(haskell-left-arrows
               (regexp . "\\(\\s-+\\)\\(<-\\|‚Üê\\)\\s-+")
               (modes quote (haskell-mode literate-haskell-mode))))
@end lisp

@node Rectangular commands
@chapter Using rectangular region commands

Emacs has a set of commands which operate on the region as if it were
rectangular. This turns out to be extremely useful when dealing with
whitespace sensitive languages.

@itemize
@item @kbd{C-x r o} is "Open Rectangle".

It will shift any text within the rectangle to the right side. Also see:

@item @kbd{C-x r t} is "String Rectangle".

It will replace any text within the rectangle with the given string on
all the lines in the region. If comment-region didn't already exist, you
could use this instead, for example.

@item @kbd{C-x r d} is "Delete Rectangle".

It will delete the contents of the rectangle and move anything on the
right over.

@item @kbd{C-x r r} is "Copy Rectangle to Register".

It will prompt you for a register number so it can save it for later.

@item @kbd{C-x r g} is "Insert register".

This will insert the contents of the given register, overwriting
whatever happens to be within the target rectangle. (So make room)

@item @kbd{C-x r k} is "Kill rectangle".

Delete rectangle and save contents for:

@item @kbd{C-x r y} is "Yank rectangle".

This will insert the contents of the last killed rectangle.
@end itemize

As with all Emacs modifier combos, you can type @kbd{C-x r C-h} to find
out what keys are bound beginning with the @kbd{C-x r} prefix.

@node REPL
@chapter Using GHCi REPL within Emacs

To start the REPL you can run one of the following:

@itemize
@item @kbd{M-x run-haskell}
@item @kbd{M-x switch-to-haskell}
@end itemize

This repl works with @uref{https://www.emacswiki.org/emacs/ComintMode, Comint}.
So you will feel at home if you are already using @kbd{M-x Shell} or @kbd{M-x ielm}.

@code{Inf-Haskell} is a Major mode for running GHCi, with comint.

Important key bindings in @code{Inf-haskell}:

@table @kbd
@item RET
invokes @kbd{comint-send-input}. Sends the input to the GHCi process, evaluates
the line and returns the output.

@item C-d or <delete>
deletes the forward character

@item <C-up> or M-p
invokes @kbd{comint-previous-input}. Cycle backwards through input history,
saving input.

@item <C-down> or M-n
invokes @kbd{comint-next-input}. Cycle forwards through input history.

@item C-c C-c
invokes @kbd{comint-interrupt-subjob}. Sends KeyboardInterrupt signal.

@item C-c C-\
invokes @kbd{comint-quit-subjob}. Sends KeyboardInterrupt signal.

@item C-c C-z
invokes @kbd{comint-stop-subjob}. Kills the GHCi process.

@item C-c M-r
invokes @kbd{comint-previous-matching-input-from-input}. If you are familiar
with @kbd{C-r} in bash. This is the same as that. Searches backwards through
input history for match for current input.

@item C-c M-s
invokes @kbd{comint-next-matching-input-from-input}. Searches forwards through
input history for match for current input.

@item C-c C-l
invokes @kbd{comint-dynamic-list-input-ring}. Displays a list of recent inputs
entered into the current buffer.

@item C-c M-o
invokes @kbd{comint-clear-buffer}. Clears the buffer (Only with Emacs 25.X and above)

@item C-c C-n
invokes @kbd{comint-next-prompt}. Goes to the start of the previous REPL prompt.

@item C-c C-p
invokes @kbd{comint-previous-prompt}. Goes to the start of the next REPL prompt.

@item C-c C-o
invokes @kbd{comint-delete-output}. Clears the output of the most recently evaluated
expression.

@item C-c C-e
invokes @kbd{comint-show-maximum-output}. Moves the point to the end of the buffer.

@item C-c C-u
invokes @kbd{comint-kill-input}. Kills backward, the line at point. (Use this when you have typed in an expression into the prompt
but you dont want to evaluate it.)

@item C-c C-w
invokes @kbd{backward-kill-word}. Kills backward, the word at point

@item C-c C-s
invokes @kbd{comint-write-output}. Write output from interpreter since last
input to FILENAME. Any prompt at the end of the output is not written.
@end table

@section Relevant defcustoms

@multitable @columnfractions .40 .20 .40
@headitem Interpreter (defcustom) @tab Default Value @tab Possible Values
@item @code{haskell-process-type} @tab @code{'auto} @tab @code{'stack-ghci, 'cabal-repl, 'ghci, 'auto}
@item @code{inferior-haskell-hook} @tab @code{nil} @tab -
@item @code{haskell-process-path-ghci} @tab @code{ghci} @tab -
@item @code{haskell-process-args-ghci} @tab @code{-ferror-spans} @tab -
@item @code{haskell-process-path-cabal} @tab @code{cabal} @tab -
@item @code{haskell-process-args-cabal-repl} @tab @code{--ghc-option=-ferror-spans} @tab -
@item @code{haskell-process-path-stack} @tab @code{stack} @tab -
@item @code{haskell-process-args-stack-ghci} @tab @code{--ghci-options=-ferror-spans --no-build --no-load} @tab -
@end multitable

@section More on @code{haskell-process-type}

The Haskell interpreter used by @code{Inf-Haskell} is auto-detected by default,
but is customizable with defcustom @code{haskell-process-type}. The values
recognized by it are (default is 'auto):

@itemize
@item @code{'stack-ghci}
@item @code{'cabal-repl}
@item @code{'ghci}
@item @code{'auto}
@end itemize

if the @code{haskell-process-type} is @code{'auto}, the directories are searched for
@code{cabal.sandbox.config} or @code{stack.yaml} or  @code{*.cabal} file.
If the file is present, then appropriate process is started.

When @code{cabal.sandbox.config} is found @code{haskell-process-type} is @code{'cabal-repl}.
Similarly, when @code{stack.yaml} is found @code{haskell-process-type} is @code{'stack-ghci}.
Similarly, when @code{xyz.cabal} is found @code{haskell-process-type} is @code{'cabal-repl}.
When nothing is found @code{haskell-process-type} is @code{'ghci}. When more than one
file such as @code{cabal.sandbox.config} and @code{stack.yaml} are found the following
preference is followed.

@code{cabal.sandbox.config} > @code{stack.yaml} >  @code{*.cabal}

@node Global-Eldoc
@chapter Shows documentation at point

@code{haskell-doc-mode} (enabled by default) shows the Type of an identifier at
point (if it exists). The type of functions/operators in Prelude are shown by
default. Other information such as the structure of @code{import}, @code{if},
@code{do} etc. is also shown.

If you want this to work with other imported modules as well, then
load the file into the repl. This can be done by pressing @kbd{C-c C-l}
from the the current buffer, provided you have @code{interactive-haskell}
minor mode enabled. Then when you place the point
on a text for more than 0.5 seconds, the type information or other
documentation information is shown.

To show type information for modules other than @code{Prelude}, we
query the comint based @code{GHCi} process for type information.

@section Related defcustoms

@multitable @columnfractions .40 .20 .40
@headitem Defcustom @tab Default value @tab Description

@item @code{haskell-doc-prettify-types}
@tab t
@tab Replace some parts of types with Unicode characters like @code{::} with
@code{‚à∑} when showing type information about symbols.

@item @code{haskell-doc-show-global-types}
@tab nil
@tab If non-nil, search for the types of global functions by loading the files.
This variable is buffer-local.

@item @code{haskell-doc-show-reserved}
@tab t
@tab If non-nil, show a documentation string for reserved ids.
This variable is buffer-local.

@item @code{haskell-doc-show-strategy}
@tab t
@tab If non-nil, show a documentation string for strategies.
This variable is buffer-local.

@item @code{haskell-doc-show-user-defined}
@tab t
@tab If non-nil, show a documentation string for user defined ids.
This variable is buffer-local.

@item @code{haskell-doc-chop-off-context}
@tab t
@tab If non-nil eliminate the context part in a Haskell type.

@item @code{haskell-doc-chop-off-fctname}
@tab nil
@tab If non-nil omit the function name and show only the type.

@end multitable

@section Adding hook

Add your hooks to @code{haskell-doc-mode-hook}. By default, nothing is
hooked to @code{haskell-doc-mode-hook}.

@node Collapsing Haskell code
@chapter Collapsing Haskell code

This is @code{hs-minor-mode} for @code{haskell-mode}. This module uses
hideshow module.

To activate this minor mode (haskell-collapse-mode)
@itemize
@item @kbd{M-x haskell-collapse-mode} is "To start haskell-collapse-mode".
@end itemize
This minor mode works with indentation.

In a quick glance:

@table @kbd
@item C-c @ C-c
is bound to @code{haskell-hide-toggle}
@item C-c @ C-M-c
@item C-c @ C-M-h
@item C-c @ C-M-s
are all bound to @code{haskell-hide-toggle-all}
@end table

How to use @code{M-x haskell-hide-toggle}?

Place your point on the code block that you want to collapse and hit the
keybinding. Now the code collapses and you can see the first line of the
block and elipsis.

Take this example code (example usage of @code{M-x haskell-hide-toggle}):
when you place the cursor here, like this (notice the thick block in the
first line):

@code{
f‚ñàx
  | rem i 3 == 0 = if i == 0 && (k /= 0) then (c k) else (h j)
  | otherwise = 0
  where i = sum x
        j = g x (div i 3) 0 0 []
        k = zeroes x 0
}

or

@code{
f x
  | rem i 3 == 0 = if i == 0 && (k /= 0) then (c k) else (h j)
‚ñà | otherwise = 0
  where i = sum x
        j = g x (div i 3) 0 0 []
        k = zeroes x 0
}

then when you collapse it becomes something like this:

@code{
f‚ñàx@dots{}
}

It works in terms of (indentation) blocks.

One more example:

@code{
f x
  | rem i 3 == 0 = if i == 0 && (k /= 0) then (c k) else (h j)
  | otherwise = 0
  w‚ñàere i = sum x
        j = g x (div i 3) 0 0 []
        k = zeroes x 0
}

or

@code{
f x
  | rem i 3 == 0 = if i == 0 && (k /= 0) then (c k) else (h j)
  | otherwise = 0
  where i = sum x
        j = g x (div i 3) 0 0 []
     ‚ñà  k = zeroes x 0
}

this, will result in something like:

@code{
f x
  | rem i 3 == 0 = if i == 0 && (k /= 0) then (c k) else (h j)
  | otherwise = 0
  where i = sum ‚ñà@dots{}
}

The other functionality @code{M-x haskell-hide-toggle-all} also
works only for indentation and it collapses all toplevel functions.

So a file that looks like this:

@example
main = interact $ show.f. map read .words
f (x:xs) = dp x xs

dp money a | money < 0 || null a = [1..1000]
dp 0 a = []
dp money a @atchar{} (coin:coins)
  | (length i) <= length j = i
  | otherwise = j
  where i = (coin:(dp (money-coin) a))
        j = (dp money coins)
@end example

will turn into this:

@example
main = interact $ show.f. map read .words
f (x:xs) = dp x xs

dp money a | money < 0 || null a = [1..1000]
dp 0 a = []
dp money a @atchar{} (coin:coins)@dots{}
@end example

@node Getting Help and Reporting Bugs
@chapter Getting Help and Reporting Bugs

Work on Haskell Mode is organized with Github @code{haskell-mode}
project.  To understand how the project is run please read the
information in the
@uref{https://github.com/haskell/haskell-mode/wiki,project wiki pages}.

To report any issues please use the Github's issue mechanism available from
@uref{https://github.com/haskell/haskell-mode,Haskell Mode's GitHub Home}.

For a quick question visit @code{#haskell-emacs} channel on IRC
@code{irc.freenode.net}.

There is also a (now defunct)
@uref{http://projects.haskell.org/cgi-bin/mailman/listinfo/haskellmode-emacs,
Haskellmode-emacs mailing list}, also available on
@uref{http://gmane.org/, Gmane} via the
@uref{http://dir.gmane.org/gmane.comp.lang.haskell.emacs,
gmane.comp.lang.haskell.emacs} newsgroup.

We welcome code and non-code contributions so that we can all enjoy
coding Haskell even more.

@node Concept index
@unnumbered Concept index

@printindex cp

@node Function index
@unnumbered Function index

@printindex fn

@node Variable index
@unnumbered Variable index

@printindex vr

@bye

@c Local Variables:
@c End:

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual is for Haskell mode, version 16.1-git

Copyright (C) 2013-2017 Haskell Mode contributors.

Permission is granted to copy, distribute and/or modify this document
under the terms of the http://www.gnu.org/licenses/fdl.html (GNU
Free Documentation License), Version 1.3 or any later version published
by the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts and no Back-Cover Texts. -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Haskell Mode 16.1-git: Interactive Haskell</title>

<meta name="description" content="Haskell Mode 16.1-git: Interactive Haskell">
<meta name="keywords" content="Haskell Mode 16.1-git: Interactive Haskell">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-index.html#Concept-index" rel="index" title="Concept index">
<link href="index.html#Top" rel="up" title="Top">
<link href="Editing-Cabal-files.html#Editing-Cabal-files" rel="next" title="Editing Cabal files">
<link href="Compilation.html#Compilation" rel="prev" title="Compilation">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="haskell-mode.css">

<link rel="shortcut icon" href="haskell-mode-32x32.png">
<script src="../../index.js"> </script>
</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<div class="background"> </div><a name="Interactive-Haskell"></a>
<div class="header">
<p>
Next: <a href="Editing-Cabal-files.html#Editing-Cabal-files" accesskey="n" rel="next">Editing Cabal files</a>, Previous: <a href="Compilation.html#Compilation" accesskey="p" rel="prev">Compilation</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="Concept-index.html#Concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Interactive-Haskell-1"></a>
<h2 class="chapter">13 Interactive Haskell</h2>

<p><acronym title="read–eval–print loop">REPL</acronym> (read–eval–print loop) is provided both via Comint
(<code>inferior-haskell-mode</code>) and an adhoc way called
<code>haskell-interactive-mode</code>. The Comint based
<code>inferior-haskell-mode</code> is just the REPL, it comes with the standard
key bindings(like <code>ielm</code> or <code>eshell</code>).
</p>
<p><code>haskell-interactive-mode</code> comes with a different set of features:
</p>
<ul>
<li> Separate sessions per Cabal project <samp>haskell-session.el</samp>.
</li><li> A new inferior Haskell process handling code <samp>haskell-process.el</samp>.
</li><li> New REPL implementation similiar to SLIME/IELM
</li><li> Navigatable error overlays
<samp>haskell-interactive-mode.el</samp>.
</li></ul>

<p>With <code>haskell-interactive-mode</code>, each Haskell source buffer is
associated with at most one GHCi session, so when you call
<code>haskell-process-load-file</code> for a Haskell source buffer which has
no session associated yet, you&rsquo;re asked which GHCi session to create or
associate with.
</p>
<a name="Goto-Error"></a>
<h3 class="section">13.1 Goto Error</h3>

<p>In a Haskell source buffer associated with a GHCi session, errors that
prevent the file from loading are highlighted with
<code>haskell-error-face</code>.  You can move between these error lines with
</p>
<dl compact="compact">
<dt><kbd>M-n</kbd></dt>
<dd><p>is bound to <code>haskell-goto-next-error</code>
</p></dd>
<dt><kbd>M-p</kbd></dt>
<dd><p>is bound to <code>haskell-goto-prev-error</code>
</p></dd>
<dt><kbd>C-c M-p</kbd></dt>
<dd><p>is bound to <code>haskell-goto-first-error</code>
</p></dd>
</dl>

<a name="Using-GHCi-8_002b-or-GHCi_002dng"></a>
<h3 class="section">13.2 Using GHCi 8+ or GHCi-ng</h3>

<p>If you use either of the above, then you can use these functions:
</p>
<div class="lisp">
<pre class="lisp">(define-key interactive-haskell-mode-map (kbd &quot;M-.&quot;) 'haskell-mode-goto-loc)
(define-key interactive-haskell-mode-map (kbd &quot;C-c C-t&quot;) 'haskell-mode-show-type-at)
</pre></div>

<p>You have to load the module before it works, after that it will remember
for the current GHCi session.
</p>
<a name="Customizing-1"></a>
<h3 class="section">13.3 Customizing</h3>

<a name="index-customizing-1"></a>
<p>What kind of Haskell REPL <code>haskell-interactive-mode</code> will start up
depends on the value of <code>haskell-process-type</code>. This can be one of the
symbols <code>auto</code>, <code>ghci</code>, <code>cabal-repl</code>, <code>cabal-new-repl</code>, or
<code>stack-ghci</code>. If it&rsquo;s <code>auto</code>, the directory contents and available
programs will be used to make a best guess at the process type. The actual
process type will then determine which variables
<code>haskell-interactive-mode</code> will access to determine the program to start
and its arguments:
</p>
<ul>
<li> If it&rsquo;s <code>ghci</code>, <code>haskell-process-path-ghci</code> and
<code>haskell-process-args-ghci</code> will be used.
</li><li> If it&rsquo;s <code>cabal-repl</code>, <code>haskell-process-path-cabal</code> and
<code>haskell-process-args-cabal-repl</code>.
</li><li> If it&rsquo;s <code>cabal-new-repl</code>, <code>haskell-process-path-cabal</code> and
<code>haskell-process-args-cabal-new-repl</code>.
</li><li> If it&rsquo;s <code>stack-ghci</code>, <code>haskell-process-path-stack</code> and
<code>haskell-process-args-stack-ghci</code> will be used.
</li></ul>

<p>With each of these pairs, the the <code>haskell-process-path-...</code>
variable needs to be a string specifying the program path, or a list of
strings where the first element is the program path and the rest are
initial arguments.  The <code>haskell-process-args-...</code> is a list of
strings specifying (further) command-line arguments.
</p>
<a name="index-haskell_002dprocess_002dtype"></a>
<a name="index-haskell_002dprocess_002dpath_002dghci"></a>
<a name="index-haskell_002dprocess_002dpath_002dcabal"></a>
<a name="index-haskell_002dprocess_002dpath_002dstack"></a>
<a name="index-haskell_002dprocess_002dargs_002dghci"></a>
<a name="index-haskell_002dprocess_002dargs_002dcabal_002drepl"></a>
<a name="index-haskell_002dprocess_002dargs_002dcabal_002dnew_002drepl"></a>
<a name="index-haskell_002dprocess_002dargs_002dstack_002dghci"></a>

<a name="Haskell-Interactive-Mode-Setup"></a>
<h3 class="section">13.4 Haskell Interactive Mode Setup</h3>

<p>The most straight-forward way to get setup with Interactive Mode is to
bind the right keybindings and set some customizations. This page
contains a good base setup.
</p>
<p>To enable the minor mode which activates keybindings associated with interactive mode, use:
</p>
<div class="lisp">
<pre class="lisp">(require 'haskell-interactive-mode)
(require 'haskell-process)
(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
</pre></div>

<a name="Customizations"></a>
<h4 class="subsection">13.4.1 Customizations</h4>

<p>This enables some handy and benign features.
</p>
<div class="lisp">
<pre class="lisp">(custom-set-variables
  '(haskell-process-suggest-remove-import-lines t)
  '(haskell-process-auto-import-loaded-modules t)
  '(haskell-process-log t))
</pre></div>


<a name="Haskell_002dmode-bindings"></a>
<h4 class="subsection">13.4.2 Haskell-mode bindings</h4>

<p>This gives the basic ways to start a session. In a Haskell buffer:
</p>
<ul>
<li> Run <kbd>C-`</kbd> to make a REPL open, this will create a
session, start GHCi, and open the REPL.
</li><li> Or: run <kbd>C-c C-l</kbd> to load the file. This will first try to start a
session as the previous command does.
</li><li> Or: run any command which requires a running session. It will always
prompt to create one if there isn&rsquo;t one already for the current project.
</li></ul>

<div class="lisp">
<pre class="lisp">(define-key haskell-mode-map (kbd &quot;C-c C-l&quot;) 'haskell-process-load-or-reload)
(define-key haskell-mode-map (kbd &quot;C-`&quot;) 'haskell-interactive-bring)
(define-key haskell-mode-map (kbd &quot;C-c C-t&quot;) 'haskell-process-do-type)
(define-key haskell-mode-map (kbd &quot;C-c C-i&quot;) 'haskell-process-do-info)
(define-key haskell-mode-map (kbd &quot;C-c C-c&quot;) 'haskell-process-cabal-build)
(define-key haskell-mode-map (kbd &quot;C-c C-k&quot;) 'haskell-interactive-mode-clear)
(define-key haskell-mode-map (kbd &quot;C-c c&quot;) 'haskell-process-cabal)
</pre></div>


<a name="Cabal_002dmode-bindings"></a>
<h4 class="subsection">13.4.3 Cabal-mode bindings</h4>

<p>The below commands pretty much match the ones above, but are handy to
have in cabal-mode, too:
</p>
<div class="lisp">
<pre class="lisp">(define-key haskell-cabal-mode-map (kbd &quot;C-`&quot;) 'haskell-interactive-bring)
(define-key haskell-cabal-mode-map (kbd &quot;C-c C-k&quot;) 'haskell-interactive-mode-clear)
(define-key haskell-cabal-mode-map (kbd &quot;C-c C-c&quot;) 'haskell-process-cabal-build)
(define-key haskell-cabal-mode-map (kbd &quot;C-c c&quot;) 'haskell-process-cabal)
</pre></div>

<a name="GHCi-process-type"></a>
<h4 class="subsection">13.4.4 GHCi process type</h4>

<p>By default <code>haskell-process-type</code> is set to <code>auto</code>. It is
smart enough to pick the right type based on your project structure and
installed tools, but in case something goes funky or you want to
explicitly set the process type and ignore the inferred type, you can
customize this setting by running <kbd>M-x</kbd> <code>customize-variable</code>
<kbd>RET</kbd> <code>haskell-process-type</code> <kbd>RET</kbd>, or by setting the code:
</p>
<div class="lisp">
<pre class="lisp">(custom-set-variables
  '(haskell-process-type 'cabal-repl))
</pre></div>

<p>Here is a list of available process types:
</p>
<ul>
<li> ghci
</li><li> cabal-repl
</li><li> cabal-new-repl
</li><li> cabal-dev
</li><li> cabal-ghci
</li><li> stack-ghci
</li></ul>

<p>Please, check the documentation for <code>haskell-process-type</code> to see how
the real type is guessed, when it&rsquo;s set to <code>auto</code>.
</p>
<a name="Troubleshooting"></a>
<h4 class="subsection">13.4.5 Troubleshooting</h4>

<p>Launching your GHCi process can fail when you&rsquo;re first getting setup,
depending on the type you choose. If it does fail to launch, switch to
the buffer <code>*haskell-process-log*</code> and see what&rsquo;s up. The buffer
contains a log of incoming/outgoing messages to the GHCi process.
</p>
<a name="Haskell-Interactive-Mode-Tags-Using-GHCi"></a>
<h3 class="section">13.5 Haskell Interactive Mode Tags Using GHCi</h3>

<p>You can bind the following to use GHCi to find definitions of things:
</p>
<div class="lisp">
<pre class="lisp">(define-key haskell-mode-map (kbd &quot;M-.&quot;) 'haskell-mode-jump-to-def)
</pre></div>

<p>The one problem with this approach is that if your code doesn&rsquo;t compile,
GHCi doesn&rsquo;t give any location info. So you need to make sure your code
compiles and the modules you want to jump to are loaded byte-compiled.
</p>
<p>Note: I think that when you restart GHCi you lose location
information, even if you have the <samp>.o</samp> and <samp>.hi</samp> files lying around. I&rsquo;m not
sure. But sometimes <code>:i foo</code> will give <code>foo is defined in Bar</code> rather
than <code>foo is defined in /foo/Bar.hs:123:23</code>.
</p>
<p>Alternatively, you can use tags generation, which doesn&rsquo;t require a
valid compile.
</p>
<a name="Tags-Setup"></a>
<h4 class="subsection">13.5.1 Tags Setup</h4>

<p>Make sure to install <samp>hasktags</samp>.
</p>
<div class="example">
<pre class="example">    $ cabal install hasktags
</pre></div>

<p>Then add the customization variable to enable tags generation on save:
</p>
<div class="lisp">
<pre class="lisp">(custom-set-variables
  '(haskell-tags-on-save t))
</pre></div>

<p>And make sure <samp>hasktags</samp> is in your <code>$PATH</code> which Emacs can see.
</p>
<a name="Generating-tags"></a>
<h4 class="subsection">13.5.2 Generating tags</h4>

<p>Now, every time you run <code>save-buffer</code> (<kbd>C-x C-s</kbd>), there is a
hook that will run and generate Emacs See <a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Tags.html#Tags">(emacs)Tags</a>, for the whole
project directory. The resulting file will be called <samp>TAGS</samp>.
</p>
<p>WARNING: You should be careful that your project root isn&rsquo;t your
home directory or something, otherwise it will traverse all the way
down and take an impossibly long time.
</p>
<a name="Jumping-to-tags"></a>
<h4 class="subsection">13.5.3 Jumping to tags</h4>

<p>Bind the following keybinding:
</p>
<div class="lisp">
<pre class="lisp">(define-key haskell-mode-map (kbd &quot;M-.&quot;) 'haskell-mode-tag-find)
</pre></div>

<p>To jump to the location of the top-level identifier at point, run
<kbd>M-x</kbd> <code>haskell-mode-tag-find</code> or <kbd>M-.</kbd>.
</p>
<a name="Hybrid_003a-GHCi-and-fallback-to-tags"></a>
<h4 class="subsection">13.5.4 Hybrid: GHCi and fallback to tags</h4>

<p>To use GHCi first and then if that fails to fallback to tags for jumping, use:
</p>
<div class="lisp">
<pre class="lisp">(define-key haskell-mode-map (kbd &quot;M-.&quot;) 'haskell-mode-jump-to-def-or-tag)
</pre></div>

<a name="Troubleshooting-tags"></a>
<h4 class="subsection">13.5.5 Troubleshooting tags</h4>

<p>Sometimes a <samp>TAGS</samp> file is deleted (by you or some other
process). Emacs will complain that it doesn&rsquo;t exist anymore. To
resolve this simply do <kbd>M-x</kbd> <code>tags-reset-tags-tables</code>.
</p>
<a name="Sessions"></a>
<h3 class="section">13.6 Sessions</h3>

<p>All commands in Haskell Interactive Mode work within a session. Consider
it like a “project” or a “solution” in popular IDEs. It tracks the root
of your project and an associated process and REPL.
</p>
<a name="Start-a-session"></a>
<h4 class="subsection">13.6.1 Start a session</h4>

<p>To start a session run the following steps:
</p>
<ul>
<li> Open some Cabal or Haskell file.
</li><li> Run <kbd>C-`</kbd> to make a REPL open, this will create a session, start
GHCi, and open the REPL.
</li><li> Or: run <kbd>C-c C-l</kbd> to load the file. This will first try to start a
session as the previous command does.
</li><li> Or: run any command which requires a running session. It will always
prompt to create one if there isn&rsquo;t one already for the current project.
</li></ul>

<p>It will prompt for a Cabal directory and a current directory. It figures
out where the cabal directory is and defaults for the current directory,
so you should be able to just hit RET twice.
</p>
<a name="Switch-a-session"></a>
<h4 class="subsection">13.6.2 Switch a session</h4>

<p>Sometimes a particular file is used in two different
sessions/projects. You can run
</p>
<div class="example">
<pre class="example">    M-x haskell-session-change
</pre></div>

<p>If it prompts you to make a new session, tell it no (that&rsquo;s a
bug). It will ask you to choose from a list of sessions.
</p>
<a name="Killing-a-session"></a>
<h4 class="subsection">13.6.3 Killing a session</h4>

<p>To kill a session you can run
</p>
<div class="example">
<pre class="example">    M-x haskell-session-kill
</pre></div>

<p>Which will prompt to kill all associated buffers, too. Hit &lsquo;n&lsquo; to
retain them.
</p>
<p>Alternatively, you can switch to the REPL and just kill the buffer
normally with <kbd>C-x k RET</kbd>. It will prompt
</p>
<div class="example">
<pre class="example">    Kill the whole session (y or n)?
</pre></div>

<p>You can choose <kbd>y</kbd> to kill the session itself, or <kbd>n</kbd> to just
kill the REPL buffer. You can bring it back with <kbd>M-x</kbd>
<code>haskell-interactive-bring</code>.
</p>
<a name="Menu"></a>
<h4 class="subsection">13.6.4 Menu</h4>

<p>To see a list of all sessions you have open with some simple
statistics about memory usage, etc. run
</p>
<div class="example">
<pre class="example">    M-x haskell-menu
</pre></div>

<p>For example:
</p>
<div class="example">
<pre class="example">    foo  14648 08:21:42 214MB /path/to/fpco/foo/  /path/to/fpco/foo/ ghci
    bar  29119 00:22:03 130MB /path/to/bar/       /path/to/bar/      ghci
    mu   22575 08:48:20 73MB  /path/to/fpco/mu/   /path/to/fpco/mu/  ghci
</pre></div>


<a name="Compiling"></a>
<h3 class="section">13.7 Compiling</h3>

<p>There are a bunch of ways to compile Haskell modules. This page covers
a few of them.
</p>
<a name="Load-into-GHCi"></a>
<h4 class="subsection">13.7.1 Load into GHCi</h4>

<p>To compile and load a Haskell module into GHCi, run the following
</p>
<div class="example">
<pre class="example">    M-x haskell-process-load
</pre></div>

<p>Or <kbd>C-c C-l</kbd>. You&rsquo;ll see any compile errors in the REPL window.
</p>
<a name="Build-the-Cabal-project"></a>
<h4 class="subsection">13.7.2 Build the Cabal project</h4>

<p>To compile the whole Cabal project, run the following
</p>
<div class="example">
<pre class="example">    M-x haskell-process-cabal-build
</pre></div>

<p>Or <kbd>C-c C-c</kbd>. You&rsquo;ll see any compile errors in the REPL window.
</p>
<a name="Reloading-modules"></a>
<h4 class="subsection">13.7.3 Reloading modules</h4>

<p>To reload the current module, even when you&rsquo;re in other modules, you can
run <kbd>C-u M-x</kbd> <code>haskell-process-load-or-reload</code> or <kbd>C-u C-c
C-l</kbd>. It will now reload that module whenever you run <kbd>C-c C-l</kbd> in
the future from whatever module you&rsquo;re in. To disable this mode, just
run <kbd>C-u C-c C-l</kbd> again.
</p>
<a name="Jumping-to-compile-errors"></a>
<h4 class="subsection">13.7.4 Jumping to compile errors</h4>

<p>You can use the standard compile error navigation function <kbd>C-x `</kbd> —
jump to the next error.
</p>
<p>Or you can move your cursor to an error in the REPL and hit <kbd>RET</kbd> to
jump to it.
</p>
<a name="Auto_002dremoving-imports"></a>
<h4 class="subsection">13.7.5 Auto-removing imports</h4>

<p>If the customization variable
<code>haskell-process-suggest-remove-import-lines</code> is enabled.
</p>
<div class="lisp">
<pre class="lisp">(custom-set-variables
  '(haskell-process-suggest-remove-import-lines t))
</pre></div>

<p>Building and loading modules which output warnings like,
</p>
<div class="example">
<pre class="example">    Warning: The import of `Control.Monad' is redundant
      except perhaps to import instances from `Control.Monad'
    To import instances alone, use: import Control.Monad()
</pre></div>

<p>will prompt the user with
</p>
<div class="example">
<pre class="example">&gt; The import line `Control.Monad' is redundant. Remove? (y, n, c: comment out)
</pre></div>

<p>If you answer
</p>
<ul>
<li> <kbd>y</kbd>: it will delete the import, but leave the empty line remaining
(this avoids messing with line positions in subsequent error messages).
</li><li> <kbd>n</kbd>: it will leave the import.
</li><li> <kbd>c</kbd>: it will comment out the import (this is handy for when you just
want to temporarily hide an import).
</li></ul>

<a name="Auto_002dadding-of-modules-to-import"></a>
<h4 class="subsection">13.7.6 Auto-adding of modules to import</h4>

<p>Enable the customization variable
<code>haskell-process-suggest-hoogle-imports</code>.
</p>
<div class="lisp">
<pre class="lisp">(custom-set-variables
  '(haskell-process-suggest-hoogle-imports t))
</pre></div>

<p>Whenever GHC says something is not in scope, it will hoogle that
symbol. If there are results, it will prompt to add one of the modules
from Hoogle&rsquo;s results.
</p>
<p>You need to make sure you&rsquo;ve generated your Hoogle database properly.
</p>
<a name="Auto_002dadding-of-extensions"></a>
<h4 class="subsection">13.7.7 Auto-adding of extensions</h4>

<p>It you use an extension which is not enabled, GHC will often inform
you. For example, if you write:
</p>
<div class="example">
<pre class="example">newtype X a = X (IO a)
  deriving (Monad)
</pre></div>


<p>Then you&rsquo;ll see a message like:
</p>
<div class="example">
<pre class="example">    x.hs:13:13: Can't make a derived instance of `Monad X': …
          `Monad' is not a derivable class
          Try -XGeneralizedNewtypeDeriving for GHC's newtype-deriving extension
        In the newtype declaration for `X'
</pre></div>

<p>This <code>-XFoo</code> pattern will be picked up and you will be prompted:
</p>
<div class="example">
<pre class="example">&gt; Add `{-# LANGUAGE GeneralizedNewtypeDeriving #-}` to the top of the
&gt; file? (y or n)
</pre></div>

<p>If you answer &lsquo;y&lsquo;, it will temporarily jump to the buffer and it to
the top of the file.
</p>
<a name="Orphan-instances"></a>
<h4 class="subsection">13.7.8 Orphan instances</h4>

<p>If GHC complains about orphan instances, you usually are doing it
intentionally, so it prompts to add <code>-fno-warn-orphans</code> to the top of
the file with an <kbd>OPTIONS</kbd> pragma.
</p>
<a name="Auto_002dadding-of-dependencies"></a>
<h4 class="subsection">13.7.9 Auto-adding of dependencies</h4>

<p>When doing a build, you will sometimes get a message from GHC like:
</p>
<div class="example">
<pre class="example">    src/ACE/Tokenizer.hs:11:18: Could not find module `Data.Attoparsec.Text' …
        It is a member of the hidden package `attoparsec-0.11.1.0'.
</pre></div>

<p>This message contains all the necessary information to add this to
your .cabal file, so you will be prompted to add it to your .cabal
file:
</p>
<div class="example">
<pre class="example">    Add `attoparsec' to ace.cabal? (y or n)  y
</pre></div>

<p>If you hit <kbd>y</kbd>, it will prompt with this:
</p>
<div class="example">
<pre class="example">    attoparsec &gt;= 0.11.1.0
</pre></div>

<p>Which you can edit (e.g. do some PVP decision or remove constraints
entirely), and then it will open up your <samp>.cabal</samp> file and go
through each section:
</p>
<div class="example">
<pre class="example">    Add to library? (y or n)  y
</pre></div>

<p>This will add it to the top of the <code>build-depends</code> field in your
library section. If you have any executables, it will go through each
of those, prompting, too.
</p>
<p>Now you can rebuild with <kbd>C-c C-c</kbd> again.
</p>
<a name="Haskell-Interactive-Mode-REPL"></a>
<h3 class="section">13.8 Haskell Interactive Mode REPL</h3>

<p>When GHCi has been launched, it works on a read-eval-print basis. So
you will be presented with the prompt:
</p>
<div class="example">
<pre class="example">    The lambdas must flow.
    Changed directory: /path/to/your/project/
    λ&gt;
</pre></div>

<a name="Changing-REPL-target"></a>
<h4 class="subsection">13.8.1 Changing REPL target</h4>

<a name="index-haskell_002dsession_002dchange_002dtarget"></a>
<a name="index-haskell_002dinteractive_002dmode_002dhook"></a>

<p>With <code>haskell-session-change-target</code> you can change the target for
REPL session.
</p>

<p>After REPL session started, in <code>haskell-interactive-mode</code> buffer invoke the
<code>haskell-session-change-target</code> and select from available targets for
</p>
<a name="index-testing"></a>
<p>- Testing
</p>
<a name="index-benchmarking"></a>
<p>- Benchmark
</p>
<p>- Executable
</p>
<p>- Library
</p>
<p>Answer &ldquo;yes&rdquo; to restart the session and run your tests, benchmarks, executables.
</p>

<p>TODO/WRITEME
</p>

<a name="Bringing-the-REPL"></a>
<h4 class="subsection">13.8.2 Bringing the REPL</h4>

<p>If you don&rsquo;t know where the REPL buffer is, you can always bring it
with:
</p>
<div class="example">
<pre class="example">    M-x haskell-interactive-bring
</pre></div>

<p>Or <kbd>C-`</kbd>.
</p>
<a name="Evaluating-expressions"></a>
<h4 class="subsection">13.8.3 Evaluating expressions</h4>

<p>To evaluate expressions, simply type one out and hit &lsquo;RET&lsquo;.
</p>
<div class="example">
<pre class="example">    λ&gt; 123
    123
</pre></div>

<a name="Evaluating-multiline-expressions"></a>
<h4 class="subsection">13.8.4 Evaluating multiline expressions</h4>

<p>GHCi features two ways to evaluate multiline expressions. You can use
<code>:set +m</code> to
enable <a href="https://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html#multiline-input">multiline input</a> for all expressions, or you can wrap your expression in
<code>:{</code> and <code>:}</code> (they have to be on their own lines).
</p>
<p>The prompt will change to indicate that you&rsquo;re inputting a multiline
expression:
</p>
<div class="example">
<pre class="example">λ&gt; :{
λ| let a = 10
λ|     b = 20
λ|     c = 30
λ| :}
</pre></div>

<p>You can also simulate multiline mode by having your input contain
newline characters. You can input a literal newline character with
<kbd>C-q C-j</kbd>, or you can use:
</p>
<div class="example">
<pre class="example">    M-x haskell-interactive-mode-newline-indent
</pre></div>

<p>which is bound to <kbd>C-j</kbd>. This command indents after the newline. You
can simulate the above example like so:
</p>
<div class="example">
<pre class="example">λ&gt; let a = 10
       b = 20
       c = 30
</pre></div>

<a name="Type-of-expressions"></a>
<h4 class="subsection">13.8.5 Type of expressions</h4>

<p>You can use normal <code>:type</code> which is part of GHCi to get the type of
something:
</p>
<div class="example">
<pre class="example">    λ&gt; :t id
    id :: a -&gt; a
</pre></div>

<p>But you can also just write out the value directly,
</p>
<div class="example">
<pre class="example">    λ&gt; id
    id :: a -&gt; a
</pre></div>

<p>and because there&rsquo;s no <code>Show</code> instance for <code>(a -&gt; a)</code>. This would
normally yield a compile error:
</p>
<div class="example">
<pre class="example">    No instance for (Show (a0 -&gt; a0))
      arising from a use of `print'
    Possible fix: add an instance declaration for (Show (a0 -&gt; a0))
    In a stmt of an interactive GHCi command: print it
</pre></div>

<p>It will run <code>:type id</code> in the background and print out the
result. The same is true for ambiguous things:
</p>
<div class="example">
<pre class="example">    λ&gt; :t read &quot;a&quot;
    read &quot;a&quot; :: Read a =&gt; a
</pre></div>

<p>Because this would normally be an ambiguous constraint:
</p>
<div class="example">
<pre class="example">    Ambiguous type variable `a0' in the constraint:
      (Read a0) arising from a use of `read'
    Probable fix: add a type signature that fixes these type variable(s)
    In the expression: read \&quot;a\&quot;
    In an equation for `it': it = read \&quot;a\&quot;
</pre></div>

<p>Which is less useful than just printing the type out.
</p>
<p>You can disable this behaviour by disabling the customization option:
</p>
<div class="lisp">
<pre class="lisp">(custom-set-variables
  '(haskell-interactive-types-for-show-ambiguous nil))
</pre></div>

<a name="Printing-mode"></a>
<h4 class="subsection">13.8.6 Printing mode</h4>

<p>You can choose between printing modes used for the results of
evaluating expressions. To do that, configure the variable
<code>haskell-interactive-mode-eval-mode</code>. Example:
</p>
<div class="lisp">
<pre class="lisp">(setq haskell-interactive-mode-eval-mode 'haskell-mode)
</pre></div>


<p>A handy function you can use is:
</p>
<div class="lisp">
<pre class="lisp">(defun haskell-interactive-toggle-print-mode ()
  (interactive)
  (setq haskell-interactive-mode-eval-mode
        (intern
         (ido-completing-read &quot;Eval result mode: &quot;
                              '(&quot;fundamental-mode&quot;
                                &quot;haskell-mode&quot;
                                &quot;espresso-mode&quot;
                                &quot;ghc-core-mode&quot;
                                &quot;org-mode&quot;)))))
</pre></div>

<p>(Add whichever modes you want to use.)
</p>
<p>And then run
</p>
<div class="example">
<pre class="example">    M-x haskell-interactive-toggle-print-mode
</pre></div>

<p>Or <kbd>C-c C-v</kbd>:
</p>
<div class="lisp">
<pre class="lisp">(define-key haskell-interactive-mode-map (kbd &quot;C-c C-v&quot;)
            'haskell-interactive-toggle-print-mode)
</pre></div>

<p>There you can choose &lsquo;haskell-mode&lsquo;, for example, to pretty print the
output as Haskell.
</p>
<a name="SVG-images-rendering"></a>
<h4 class="subsection">13.8.7 <acronym>SVG</acronym> images rendering</h4>

<a name="index-Rendering-SVG-images"></a>
<a name="index-SVG-images_002c-rendering"></a>
<a name="index-Images_002c-rendering-SVG-images"></a>

<p>If you are working on <acronym>SVG</acronym> images, you can instruct Emacs to
render the image as the output of an image producing command at the
<acronym title="read–eval–print loop">REPL</acronym>.
</p>
<p>The following example uses the <code>diamgrams</code> library with the default
<acronym>SVG</acronym> backend to produce a circle:
</p>
<div class="example">
<pre class="example">    {-# LANGUAGE OverloadedStrings #-}

    import Diagrams.Prelude
    import Diagrams.Backend.SVG

    myCircle :: Diagram B
    myCircle = circle 1 # lc purple # fc yellow

    circle = renderDia SVG (SVGOptions (mkWidth 250) Nothing &quot;&quot; [] True) myCircle
</pre></div>

<a name="index-haskell_002dsvg_002dtoggle_002drender_002dimages"></a>

<p>After enabling <acronym>SVG</acronym> rendering with <kbd>M-x
haskell-svg-toggle-render-images</kbd>, if you load the above code and type
<code>circle</code> at the <acronym title="read–eval–print loop">REPL</acronym>, you will see the rendered circle
instead of the <acronym>XML</acronym> representation of the image.
</p>
<a name="index-haskell_002dsvg_002drender_002dimages"></a>

<p>This feature can be enabled by default by setting the customization
variable <code>haskell-svg-render-images</code> to a non-nil value.
</p>
<a name="Presentations"></a>
<h4 class="subsection">13.8.8 Presentations</h4>

<p>If you have the <samp>present</samp> package installed, you can use the following
syntax to print anything which is an instance of <code>Data</code>:
</p>
<div class="example">
<pre class="example">    λ&gt; :present 123
    123
</pre></div>

<p>It will print data structures lazily:
</p>
<div class="example">
<pre class="example">    λ&gt; :present [1..]
    [1
    ,[Integer]]
</pre></div>

<p>It shows types when there is an unevaluated field in a constructor. You
can click the <code>[Integer]</code> or press <kbd>RET</kbd> on it to expand
further:
</p>
<div class="example">
<pre class="example">    λ&gt; :present [1..]
    [1
    ,2
    ,[Integer]]
</pre></div>

<p>Etc. Remember: this only works for instances of <code>Data.Data.Data</code>.
</p>
<a name="History-1"></a>
<h4 class="subsection">13.8.9 History</h4>

<p>A history is maintained for the duration of the REPL buffer. To go up
and down in the history, run <kbd>M-p</kbd> for previous and <kbd>M-n</kbd> for
next.
</p>
<a name="Cancelling-commands"></a>
<h4 class="subsection">13.8.10 Cancelling commands</h4>

<p>To cancel a running REPL command, run <kbd>C-c C-c</kbd>.
</p>
<a name="Clear-the-REPL"></a>
<h4 class="subsection">13.8.11 Clear the REPL</h4>

<p>Run <kbd>C-c C-k</kbd> to clear the REPL.
</p>

<a name="Trick_003a-Put-Interactive-REPL-in-Separate-Frame"></a>
<h4 class="subsection">13.8.12 Trick: Put Interactive REPL in Separate Frame</h4>


<p>The following <code>create-haskell-interactive-frame</code> is a quick hack to
move the repl to a separate frame, for those that want a more
predictable layout of windows in Emacs.
</p>
<div class="lisp">
<pre class="lisp">(defun create-unfocused-frame ()
  (let*
    ((prv (window-frame))
     (created (make-frame)))
    (select-frame-set-input-focus prv) created))

(defun create-haskell-interactive-frame ()
  (interactive)
  (haskell-interactive-bring)
  (create-unfocused-frame)
  (delete-window))

</pre></div>

<a name="Troubleshooting-1"></a>
<h4 class="subsection">13.8.13 Troubleshooting</h4>

<p>If the REPL ever goes funny, you can clear the command queue via:
</p>
<div class="example">
<pre class="example">    M-x haskell-process-clear
</pre></div>

<p>Alternatively, you can just restart the process:
</p>
<div class="example">
<pre class="example">    M-x haskell-process-restart
</pre></div>

<p>You can also switch to the buffer <code>*haskell-process-log*</code>, which can
be enabled and disabled with the customization variable
&lsquo;haskell-process-log&lsquo;, to see what the cause of your troubles are.
</p>
<p>If the process fails and nothing unusual is in the process log, the
following command can dump the <code>haskell-process</code> state:
</p>
<div class="example">
<pre class="example">    M-: (haskell-process)
</pre></div>

<p>The output can be copied from the <code>*Messages*</code> buffer.
</p>
<a name="Haskell-Interactive-Mode-Querying"></a>
<h3 class="section">13.9 Haskell Interactive Mode Querying</h3>

<p>There a few ways GHCi lets you query information about your code.
</p>
<a name="Get-identifer-type"></a>
<h4 class="subsection">13.9.1 Get identifer type</h4>

<p>To print the type of the top-level identifier at point in the REPL and
in the message buffer, run the following command:
</p>
<div class="example">
<pre class="example">    M-x haskell-process-do-type
</pre></div>

<p>or <kbd>C-c C-t</kbd>.
</p>
<a name="Insert-identifier_0027s-type-as-type-signature"></a>
<h4 class="subsection">13.9.2 Insert identifier&rsquo;s type as type signature</h4>

<p>To print the type of the top-level identifier at point, run the
following command:
</p>
<div class="example">
<pre class="example">    C-u M-x haskell-process-do-type
</pre></div>

<p>or <kbd>C-u C-c C-t</kbd>.
</p>
<a name="Get-identifier-info"></a>
<h4 class="subsection">13.9.3 Get identifier info</h4>

<p>To print the info of the identifier at point, run the following
command:
</p>
<div class="example">
<pre class="example">    M-x haskell-process-do-info
</pre></div>

<p>or <kbd>C-c C-i</kbd>.
</p>
<a name="Presentation-mode"></a>
<h4 class="subsection">13.9.4 Presentation mode</h4>

<p>When using <kbd>C-c C-i</kbd> or <kbd>C-c C-t</kbd> it will open a buffer in
haskell-presentation-mode. You can hit <kbd>q</kbd> to close the buffer.
</p>
<p>But you can also continue to use <kbd>C-c C-i</kbd> inside the buffer to
drill further down data types and classes.
</p>
<p>E.g. if you go to <code>Ord</code> in your code buffer and <kbd>C-c C-i</kbd>, it
will popup a buffer containing
</p>
<div class="example">
<pre class="example">class Eq a =&gt; Ord a where
  compare :: a -&gt; a -&gt; Ordering
  (&lt;) :: a -&gt; a -&gt; Bool
  (&gt;=) :: a -&gt; a -&gt; Bool
  (&gt;) :: a -&gt; a -&gt; Bool
  (&lt;=) :: a -&gt; a -&gt; Bool
  max :: a -&gt; a -&gt; a
  min :: a -&gt; a -&gt; a
  	-- Defined in `GHC.Classes'
</pre></div>

<p>And all the instances of that class. But then you can also move your
cursor to <code>Ordering</code> and hit <kbd>C-c C-i</kbd> again to get another
popup:
</p>
<div class="example">
<pre class="example">data Ordering = LT | EQ | GT 	-- Defined in `GHC.Types'
instance Bounded Ordering -- Defined in `GHC.Enum'
instance Enum Ordering -- Defined in `GHC.Enum'
instance Eq Ordering -- Defined in `GHC.Classes'
instance Ord Ordering -- Defined in `GHC.Classes'
instance Read Ordering -- Defined in `GHC.Read'
instance Show Ordering -- Defined in `GHC.Show'
</pre></div>

<p>And so on. It&rsquo;s a very good way of exploring a new codebase.
</p>
<a name="Browse-import_0027s-module"></a>
<h4 class="subsection">13.9.5 Browse import&rsquo;s module</h4>

<p>To print all exported identifiers of the module imported by the import
line at point, run the following command:
</p>
<div class="example">
<pre class="example">    M-x haskell-process-do-info
</pre></div>

<p>or <kbd>C-c C-i</kbd>. It will print all exports by running <code>:browse
The.Module</code> in the GHCi process.
</p>
<a name="Haskell-Interactive-Mode-Cabal-integration"></a>
<h3 class="section">13.10 Haskell Interactive Mode Cabal integration</h3>

<p>There&rsquo;s some integration with Cabal in Haskell Interactive Mode. Once
you&rsquo;ve started a session, the features below are available.
</p>
<a name="Cabal-building"></a>
<h4 class="subsection">13.10.1 Cabal building</h4>

<p>The most common Cabal action is building, so that has a specific command:
</p>
<div class="example">
<pre class="example">    M-x haskell-process-cabal-build
</pre></div>

<p>Or <kbd>C-c C-c</kbd>. When building, it will hide unneccessary output.
</p>
<p>For example, to build the &lsquo;ace&lsquo; package, the output is simply:
</p>
<div class="example">
<pre class="example">    Compiling: ACE.Types.Tokens
    Compiling: ACE.Combinators
    Compiling: ACE.Tokenizer
    Compiling: ACE.Parsers
    Compiling: ACE.Pretty
    Compiling: ACE
    Complete: cabal build (0 compiler messages)
</pre></div>

<p>Whereas the complete output is normally:
</p>
<div class="example">
<pre class="example">    Building ace-0.5...
    Preprocessing library ace-0.5...
    [4 of 9] Compiling ACE.Types.Tokens ( src/ACE/Types/Tokens.hs, dist/build/ACE/Types/Tokens.o )
    [5 of 9] Compiling ACE.Combinators  ( src/ACE/Combinators.hs, dist/build/ACE/Combinators.o ) [ACE.Types.Tokens changed]
    [6 of 9] Compiling ACE.Tokenizer    ( src/ACE/Tokenizer.hs, dist/build/ACE/Tokenizer.o ) [ACE.Types.Tokens changed]
    [7 of 9] Compiling ACE.Parsers      ( src/ACE/Parsers.hs, dist/build/ACE/Parsers.o )
    [8 of 9] Compiling ACE.Pretty       ( src/ACE/Pretty.hs, dist/build/ACE/Pretty.o )
    [9 of 9] Compiling ACE              ( src/ACE.hs, dist/build/ACE.o ) [ACE.Tokenizer changed]
    In-place registering ace-0.5...
</pre></div>

<p>Which is considerably more verbose but rarely useful or interesting.
</p>
<a name="Arbitrary-cabal-commands"></a>
<h4 class="subsection">13.10.2 Arbitrary cabal commands</h4>

<p>To run an arbitrary Cabal command:
</p>
<div class="example">
<pre class="example">    C-u M-x haskell-process-cabal
</pre></div>

<p>Or run <kbd>C-u C-c c</kbd>.
</p>
<p>It will prompt for an input, so you can write <code>configure -fdev</code>,
for example.
</p>
<a name="Completing-cabal-commands"></a>
<h4 class="subsection">13.10.3 Completing cabal commands</h4>

<p>To run some common Cabal commands, just run:
</p>
<div class="example">
<pre class="example">    M-x haskell-process-cabal
</pre></div>

<p>Or <kbd>C-c c</kbd>. This is commonly used to do <code>install</code>,
<code>haddock</code>, <code>configure</code>, etc.
</p>
<a name="Haskell-Interactive-Mode-Debugger"></a>
<h3 class="section">13.11 Haskell Interactive Mode Debugger</h3>

<p>There is limited support for debugging in GHCi. Haskell Interactive Mode
provides an interface for interacting with this.
</p>
<a name="Opening-the-debug-buffer"></a>
<h4 class="subsection">13.11.1 Opening the debug buffer</h4>

<p>To open the debug buffer run the following command from any buffer
associated with a session:
</p>
<div class="example">
<pre class="example">    M-x haskell-debug
</pre></div>

<p>It will open a buffer that looks like this:
</p>
<div class="example">
<pre class="example">    Debugging haskell

    You have to load a module to start debugging.

    g - refresh

    Modules

    No loaded modules.
</pre></div>


<a name="Loading-modules"></a>
<h4 class="subsection">13.11.2 Loading modules</h4>

<p>To debug anything you need to load something into GHCi. Switch to a
normal file, for example:
</p>
<div class="example">
<pre class="example">main = do putStrLn &quot;Hello!&quot;
          putStrLn &quot;World&quot;
</pre></div>

<p>and load it into GHCi (<kbd>C-c C-l</kbd>). Now when you hit <kbd>g</kbd>
(to refresh) in the debugging buffer, you&rsquo;ll see something like:
</p>
<div class="example">
<pre class="example">
    Debugging haskell

    b - breakpoint, g - refresh

    Context

    Not debugging right now.

    Breakpoints

    No active breakpoints.

    Modules

    Main - hello.hs
</pre></div>

<a name="Setting-a-breakpoint"></a>
<h4 class="subsection">13.11.3 Setting a breakpoint</h4>

<p>To set a breakpoint hit <kbd>b</kbd> in the debugger buffer. It will prompt
for a name. Enter <code>main</code> and hit <kbd>RET</kbd>.
</p>
<p>Now the buffer will look like this:
</p>
<div class="example">
<pre class="example">    Debugging haskell

    s - step into an expression, b - breakpoint
    d - delete breakpoint, g - refresh

    Context

    Not debugging right now.

    Breakpoints

    0 - Main (1:8)

    Modules

    Main - hello.hs
</pre></div>

<a name="Start-stepping"></a>
<h4 class="subsection">13.11.4 Start stepping</h4>

<p>Hit <kbd>s</kbd> to step through an expression: it will prompt for an
expression to evaluate and step through. Enter <code>main</code> and hit
<kbd>RET</kbd>. Now the buffer will look like this:
</p>
<div class="example">
<pre class="example">    Debugging haskell

    s - step into an expression, b - breakpoint
    d - delete breakpoint, a - abandon context, c - continue
    p - previous step, n - next step
    g - refresh

    Context

    main - hello.hs (stopped)

    do putStrLn &quot;Hello!&quot;
       putStrLn &quot;World&quot;

    _result :: IO () = _

       1 do putStrLn &quot;Hello!&quot; putStrLn &quot;World&quot;

    Breakpoints

    0 - Main (1:8)

    Modules

    Main - hello.hs
</pre></div>

<p>What we see here is the current expression being evaluated:
</p>
<div class="example">
<pre class="example">do putStrLn &quot;Hello!&quot;
   putStrLn &quot;World&quot;
</pre></div>

<p>And we see the type of it:
</p>
<div class="example">
<pre class="example">_result :: IO () = _
</pre></div>

<p>And we see a backtrace of steps so far:
</p>
<div class="example">
<pre class="example">1 do putStrLn &quot;Hello!&quot; putStrLn &quot;World&quot;
</pre></div>

<a name="Continue-stepping"></a>
<h4 class="subsection">13.11.5 Continue stepping</h4>

<p>To continue stepping, just hit <kbd>s</kbd> again. Now the context will change
to:
</p>
<div class="example">
<pre class="example">main - hello.hs (stopped)

putStrLn &quot;Hello!&quot;

_result :: IO () = _

   1 do putStrLn &quot;Hello!&quot; putStrLn &quot;World&quot;
</pre></div>


<p>Hitting <kbd>s</kbd> once more, we see the context change to:
</p>
<div class="example">
<pre class="example">putStrLn &quot;World&quot;

_result :: IO () = _

   2 putStrLn &quot;Hello!&quot;
   1 do putStrLn &quot;Hello!&quot; putStrLn &quot;World&quot;
</pre></div>

<p>Finally hitting <kbd>s</kbd> again will say &quot;Computation finished&quot;. Hitting
<kbd>s</kbd> a final time will change the display back to:
</p>
<div class="example">
<pre class="example">    Debugging haskell

    s - step into an expression, b - breakpoint
    d - delete breakpoint, g - refresh

    Context

    Finished debugging.

       2 putStrLn &quot;Hello!&quot;
       1 do putStrLn &quot;Hello!&quot; putStrLn &quot;World&quot;

    Breakpoints

    1 - Main (1:8)

    Modules

    Main - hello.hs
</pre></div>

<p>And you&rsquo;re done debugging.
</p>

<hr>
<div class="header">
<p>
Next: <a href="Editing-Cabal-files.html#Editing-Cabal-files" accesskey="n" rel="next">Editing Cabal files</a>, Previous: <a href="Compilation.html#Compilation" accesskey="p" rel="prev">Compilation</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="Concept-index.html#Concept-index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
